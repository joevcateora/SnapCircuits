/*
  Snapduino Candle
  This experiment will simulate a candle using an LED and 
  allow you to blow it out using the whistle chip.

  Daniel Porrey
  https://www.hackster.io/snapcircuits

*/

// ***
// *** The ATtiny85 does not have a built in serial device. To
// *** communicate with the computer over the FTDI cable we need
// *** a serial port emulator.
// ***
#include <SoftwareSerial.h>

// ***
// *** Define the RX and TX pins. Since we already have the FTDI
// *** cable attached for programing, let's use the same pins!
// ***
#define TX    YELLOW_PIN    // *** PB0, D0, ATtiny85 pin 5, Yellow Cable
#define RX    WHITE_PIN     // *** PB1, D1, ATtiny85 pin 6, White Cable

// ***
// *** Define the software based serial port. Using the
// *** name Serial so that code can be used on other
// *** platforms that support hardware based serial. On
// *** chips that support the hardware serial, just
// *** comment this line.
// ***
SoftwareSerial Serial(RX, TX);

// ***
// *** The pin on which the LED is connected.
// ***
#define LED_PIN 4

// ***
// *** The pin on which the LED is connected.
// ***
#define WHISTLE_CHIP_PIN 2

// ***
// *** Minimum and maximum values for the LED output.
// *** do not want the candle to appear to go out so
// *** we are setting the minimum vaue to something
// *** other than 0. This is applied to the PWM output
// *** using analogWrite() which can accept a value
// *** 0 and 255.
// ***
#define MINIMUM_VALUE 75
#define MAXIMUM_VALUE 255


// ***
// *** Minimum and maximum values the delay time
// *** between intensity changes. These valus are
// *** in millisesonds.
// ***
#define MINIMUM_DELAY_VALUE 5
#define MAXIMUM_DELAY_VALUE 15

// ***
// *** Stores the current output for the LED.
// ***
int _currentValue = 0;

// ***
// *** Stores the next output for the LED.
// ***
int _nextValue = 0;

// ***
// *** Determines if the LED should be on or off.
// ***
bool _candleIsOn = true;

void setup()
{
  // ***
  // *** Initialize the Serial port
  // ***
  Serial.begin(115200);
  Serial.println("Initializing...");

  // ***
  // *** If it is important for a sequence of values generated by random() to differ,
  // *** on subsequent executions of a sketch, use randomSeed() to initialize the random
  // *** number generator with a fairly random input, such as analogRead() on an
  // *** unconnected pin.
  // ***
  randomSeed(analogRead(0));

  // ***
  // *** Start with the LED at the minimum value.
  // ***
  analogWrite(LED_PIN, MINIMUM_VALUE);

  // ***
  // *** Initialize the pin the whistle chip
  // *** is conecte dot and set the mode to
  // *** input with a pullup resistor.
  // ***
  pinMode(WHISTLE_CHIP_PIN, INPUT);

  // ***
  // *** Attach an interrupt. Each time the value of the pin changes to
  // *** LOW the function onInterrupt() will be called.
  // ***
  attachInterrupt(0, onInterrupt, FALLING); 

  // ***
  // *** Report the end ofinitialization
  // *** to the serial port monitor.
  // ***
  Serial.println("Initialization complete.");
}

void onInterrupt()
{
  // ***
  // *** Display the count on the serial device
  // ***
  _candleIsOn = !_candleIsOn;
  Serial.print("The candle is "); if (_candleIsOn) Serial.println(" on."); else Serial.println(" off.");
}

void loop()
{
  if (_candleIsOn)
  {
    // ***
    // *** Each time this is called, the candle
    // *** intensity will change by 1.
    // ***
    iterateCandleFlicker();
  }
  else
  {
    // ***
    // *** Turn the LED off.
    // ***
    analogWrite(LED_PIN, 0);
  }
}

void iterateCandleFlicker()
{
  // ***
  // *** Write the current value;
  // ***
  analogWrite(LED_PIN, _currentValue);

  // ***
  // *** The lED will never change values suddenly, it
  // *** is always faded from one value to another.
  // *** Check if the current value has reached
  // *** the next value.
  // ***
  if (_currentValue != _nextValue)
  {
    // ***
    // *** If the next value is higher, increment,
    // *** otherwise decrement.
    // ***
    if (_currentValue < _nextValue)
    {
      // ***
      // *** Increment the current value;
      // ***
      _currentValue++;
    }
    else
    {
      // ***
      // *** Decrement the current value;
      // ***
      _currentValue--;
    }
  }
  else
  {
    // ***
    // *** Set the current value.
    // ***
    _currentValue = _nextValue;

    // ***
    // *** Calculate the next value to set the LED to
    // *** using a random number generator.
    // ***
    _nextValue = random(MINIMUM_VALUE, MAXIMUM_VALUE);

    // ***
    // *** Display the values on the srial port
    // *** monitor.
    // ***
    Serial.print("Current value = "); Serial.print(_currentValue); Serial.print(", Next Value = "); Serial.println(_nextValue);
  }

  // ***
  // *** Calculate a random delay time (very
  // *** short, but random).
  // ***
  long delayTime = random(MINIMUM_DELAY_VALUE, MAXIMUM_DELAY_VALUE);
  delay(delayTime);
}
